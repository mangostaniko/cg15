<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Seganku: Geometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Seganku
   </div>
   <div id="projectbrief">Help Segi the skunk survive. Find carrots and hide from the shadows of the sky.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classGeometry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Geometry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classGeometry.html" title="A Geometry is a SceneObject that holds Surfaces which contain mesh data and textures. ">Geometry</a> is a <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> that holds Surfaces which contain mesh data and textures.  
 <a href="classGeometry.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="geometry_8h_source.html">geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Geometry:</div>
<div class="dyncontent">
<div class="center"><img src="classGeometry__inherit__graph.png" border="0" usemap="#Geometry_inherit__map" alt="Inheritance graph"/></div>
<map name="Geometry_inherit__map" id="Geometry_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Geometry:</div>
<div class="dyncontent">
<div class="center"><img src="classGeometry__coll__graph.png" border="0" usemap="#Geometry_coll__map" alt="Collaboration graph"/></div>
<map name="Geometry_coll__map" id="Geometry_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8d30f5ea8f87f647a25dbfa70e1ec033"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d30f5ea8f87f647a25dbfa70e1ec033"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Geometry</b> (const glm::mat4 &amp;matrix_, const std::string &amp;filePath)</td></tr>
<tr class="separator:a8d30f5ea8f87f647a25dbfa70e1ec033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7146c1743d75b861a1d310aefe863068"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#a7146c1743d75b861a1d310aefe863068">update</a> (float timeDelta)</td></tr>
<tr class="memdesc:a7146c1743d75b861a1d310aefe863068"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the state of the <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a>  <a href="#a7146c1743d75b861a1d310aefe863068">More...</a><br /></td></tr>
<tr class="separator:a7146c1743d75b861a1d310aefe863068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407b6088bfb5f21e6a185fa28593ef49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a407b6088bfb5f21e6a185fa28593ef49"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#a407b6088bfb5f21e6a185fa28593ef49">draw</a> (<a class="el" href="classShader.html">Shader</a> *shader, <a class="el" href="classCamera.html">Camera</a> *camera, bool useFrustumCulling, Texture::FilterType filterType, const glm::mat4 &amp;viewMat)</td></tr>
<tr class="memdesc:a407b6088bfb5f21e6a185fa28593ef49"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw the <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> using given shader <br /></td></tr>
<tr class="separator:a407b6088bfb5f21e6a185fa28593ef49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa918fc922ada5e9fb838bd502602b475"><td class="memItemLeft" align="right" valign="top">glm::mat3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#aa918fc922ada5e9fb838bd502602b475">getNormalMatrix</a> () const </td></tr>
<tr class="memdesc:aa918fc922ada5e9fb838bd502602b475"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a the transposed inverse of the modelMatrix. this should be used to transform normals into world space. the inverse is used since the normals of a scaled vector are inversely scaled, the transpose is used to revert the inversion of the rotational components while not affecting the scale factors which lie on the main diagonal. mat3 is used since the translational component is irrelevant for normals.  <a href="#aa918fc922ada5e9fb838bd502602b475">More...</a><br /></td></tr>
<tr class="separator:aa918fc922ada5e9fb838bd502602b475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1089e0f8c94ea63b4824026873d47ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1089e0f8c94ea63b4824026873d47ea0"></a>
<a class="el" href="classSurface.html">Surface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSurface</b> ()</td></tr>
<tr class="separator:a1089e0f8c94ea63b4824026873d47ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSceneObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSceneObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSceneObject.html">SceneObject</a></td></tr>
<tr class="memitem:ad362cceccda728875f60632e4da3db97 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad362cceccda728875f60632e4da3db97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SceneObject</b> (const glm::mat4 &amp;modelMatrix_)</td></tr>
<tr class="separator:ad362cceccda728875f60632e4da3db97 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b495737a6506e9cb695d8afb280f0c6 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a7b495737a6506e9cb695d8afb280f0c6">applyTransformation</a> (const glm::mat4 &amp;transform_, const glm::mat4 &amp;inverse_, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a7b495737a6506e9cb695d8afb280f0c6 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a transformation matrix to the current matrix  <a href="#a7b495737a6506e9cb695d8afb280f0c6">More...</a><br /></td></tr>
<tr class="separator:a7b495737a6506e9cb695d8afb280f0c6 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44faac928424a61d1863bb6829cdf13 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">const glm::mat4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#ab44faac928424a61d1863bb6829cdf13">getMatrix</a> () const </td></tr>
<tr class="separator:ab44faac928424a61d1863bb6829cdf13 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d115838f7df8410a6f36a5ba4eb5bc4 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a4d115838f7df8410a6f36a5ba4eb5bc4">setTransform</a> (const glm::mat4 &amp;matrix_)</td></tr>
<tr class="memdesc:a4d115838f7df8410a6f36a5ba4eb5bc4 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces current matrix and sets its inverse  <a href="#a4d115838f7df8410a6f36a5ba4eb5bc4">More...</a><br /></td></tr>
<tr class="separator:a4d115838f7df8410a6f36a5ba4eb5bc4 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682edfd29e01e917f288fb951cc4140d inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">const glm::mat4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a682edfd29e01e917f288fb951cc4140d">getInverseMatrix</a> () const </td></tr>
<tr class="separator:a682edfd29e01e917f288fb951cc4140d inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11049eac3dbfcc2b55a44a0064d2e5f4 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a11049eac3dbfcc2b55a44a0064d2e5f4">getLocation</a> () const </td></tr>
<tr class="memdesc:a11049eac3dbfcc2b55a44a0064d2e5f4 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the location of the <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> by convention, that is the rightmost column of the model matrix, defined to always be multiplied with a factor of 1, such that in the linear combination of the matrix multiplication it acts like a translation independent of the xyz values of the given point, thus specifying the origin of the model matrix.  <a href="#a11049eac3dbfcc2b55a44a0064d2e5f4">More...</a><br /></td></tr>
<tr class="separator:a11049eac3dbfcc2b55a44a0064d2e5f4 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4f5ed018a9c32c81c6d2f9483b49d9 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a5e4f5ed018a9c32c81c6d2f9483b49d9">setLocation</a> (const glm::vec3 &amp;location)</td></tr>
<tr class="memdesc:a5e4f5ed018a9c32c81c6d2f9483b49d9 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the location of the <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> i.e. rightmost column of the model matrix  <a href="#a5e4f5ed018a9c32c81c6d2f9483b49d9">More...</a><br /></td></tr>
<tr class="separator:a5e4f5ed018a9c32c81c6d2f9483b49d9 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23654f0c10aa113c3c43a8fb7fac2637 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a23654f0c10aa113c3c43a8fb7fac2637">rotateX</a> (float radians, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a23654f0c10aa113c3c43a8fb7fac2637 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies an X axis rotation operation to the current transformation  <a href="#a23654f0c10aa113c3c43a8fb7fac2637">More...</a><br /></td></tr>
<tr class="separator:a23654f0c10aa113c3c43a8fb7fac2637 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d588db113ce844fe1d022a3cae38ff5 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a3d588db113ce844fe1d022a3cae38ff5">rotateY</a> (float radians, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a3d588db113ce844fe1d022a3cae38ff5 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a Y axis rotation operation to the current transformation  <a href="#a3d588db113ce844fe1d022a3cae38ff5">More...</a><br /></td></tr>
<tr class="separator:a3d588db113ce844fe1d022a3cae38ff5 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33041ba7b98378e0fb5abe57145b5609 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a33041ba7b98378e0fb5abe57145b5609">rotateZ</a> (float radians, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a33041ba7b98378e0fb5abe57145b5609 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a Z axis rotation operation to the current transformation  <a href="#a33041ba7b98378e0fb5abe57145b5609">More...</a><br /></td></tr>
<tr class="separator:a33041ba7b98378e0fb5abe57145b5609 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07481cd1ccd6028a11326338364529bb inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a07481cd1ccd6028a11326338364529bb">rotate</a> (float radians, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder, const glm::vec3 &amp;axis_)</td></tr>
<tr class="memdesc:a07481cd1ccd6028a11326338364529bb inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a rotation around a given vector (= axis)  <a href="#a07481cd1ccd6028a11326338364529bb">More...</a><br /></td></tr>
<tr class="separator:a07481cd1ccd6028a11326338364529bb inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e14aad2d1ca862e92873542c3fc86 inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a653e14aad2d1ca862e92873542c3fc86">translate</a> (const glm::vec3 &amp;t_, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a653e14aad2d1ca862e92873542c3fc86 inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a translation operation to the current transformation  <a href="#a653e14aad2d1ca862e92873542c3fc86">More...</a><br /></td></tr>
<tr class="separator:a653e14aad2d1ca862e92873542c3fc86 inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c9e8a1cae5e12d0afb7e2a16b3026a inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a68c9e8a1cae5e12d0afb7e2a16b3026a">scale</a> (const glm::vec3 &amp;s_, <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> multOrder)</td></tr>
<tr class="memdesc:a68c9e8a1cae5e12d0afb7e2a16b3026a inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a scale operation to the current transformation  <a href="#a68c9e8a1cae5e12d0afb7e2a16b3026a">More...</a><br /></td></tr>
<tr class="separator:a68c9e8a1cae5e12d0afb7e2a16b3026a inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc1ddd01745f521709b24227c41dd8d inherit pub_methods_classSceneObject"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a6fc1ddd01745f521709b24227c41dd8d">matrixToString</a> (const glm::mat4 &amp;matrix)</td></tr>
<tr class="memdesc:a6fc1ddd01745f521709b24227c41dd8d inherit pub_methods_classSceneObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string to visualize the given matrix  <a href="#a6fc1ddd01745f521709b24227c41dd8d">More...</a><br /></td></tr>
<tr class="separator:a6fc1ddd01745f521709b24227c41dd8d inherit pub_methods_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5c2eda4cbb5e206df16b4a68f55673c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c2eda4cbb5e206df16b4a68f55673c9"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>drawnSurfaceCount</b> = 0</td></tr>
<tr class="separator:a5c2eda4cbb5e206df16b4a68f55673c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeed1fc7590be736468e6d2b0845e5c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#aeed1fc7590be736468e6d2b0845e5c73">loadSurfaces</a> (const std::string &amp;filePath)</td></tr>
<tr class="memdesc:aeed1fc7590be736468e6d2b0845e5c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">load surfaces from file note: this loads only the first diffuse, specular and normal texture for each surface and stores them in this order in the surface  <a href="#aeed1fc7590be736468e6d2b0845e5c73">More...</a><br /></td></tr>
<tr class="separator:aeed1fc7590be736468e6d2b0845e5c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ea6e3fb86cfef73973b64b86fd64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#a5a1ea6e3fb86cfef73973b64b86fd64e">processNode</a> (aiNode *node, const aiScene *scene)</td></tr>
<tr class="memdesc:a5a1ea6e3fb86cfef73973b64b86fd64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">process all meshes contained in given node and recursively process all child nodes  <a href="#a5a1ea6e3fb86cfef73973b64b86fd64e">More...</a><br /></td></tr>
<tr class="separator:a5a1ea6e3fb86cfef73973b64b86fd64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac853ba774a9bcefbc24d6e5934ea6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#a1ac853ba774a9bcefbc24d6e5934ea6a">processMesh</a> (aiMesh *mesh, const aiScene *scene)</td></tr>
<tr class="memdesc:a1ac853ba774a9bcefbc24d6e5934ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">load data from assimp aiMesh to new <a class="el" href="classSurface.html" title="A Surface holds mesh data (vertex data and indices) and textures. This communicates with Vertex Buffe...">Surface</a> object note: this loads only the first diffuse, specular and normal texture for each surface and stores them in this order in the surface  <a href="#a1ac853ba774a9bcefbc24d6e5934ea6a">More...</a><br /></td></tr>
<tr class="separator:a1ac853ba774a9bcefbc24d6e5934ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642e705400989b354f1c001813bbf7b6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classTexture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry.html#a642e705400989b354f1c001813bbf7b6">loadMaterialTexture</a> (aiMaterial *mat, aiTextureType type)</td></tr>
<tr class="memdesc:a642e705400989b354f1c001813bbf7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">load assimp aiMesh texture of given type. textures of same filePath are reused among the geometry object.  <a href="#a642e705400989b354f1c001813bbf7b6">More...</a><br /></td></tr>
<tr class="separator:a642e705400989b354f1c001813bbf7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a21a79047e78f52cf99bda83ac050a1f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a79047e78f52cf99bda83ac050a1f8"></a>
std::vector&lt; std::shared_ptr<br class="typebreak" />
&lt; <a class="el" href="classSurface.html">Surface</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>surfaces</b></td></tr>
<tr class="separator:a21a79047e78f52cf99bda83ac050a1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958834d03260ef2a6dfb47faeaca7dc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a958834d03260ef2a6dfb47faeaca7dc3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>directoryPath</b></td></tr>
<tr class="separator:a958834d03260ef2a6dfb47faeaca7dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a6dc6838eacd8456d48603f4238954ebd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dc6838eacd8456d48603f4238954ebd"></a>
static std::vector<br class="typebreak" />
&lt; std::shared_ptr&lt; <a class="el" href="classTexture.html">Texture</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>loadedTextures</b> = {}</td></tr>
<tr class="separator:a6dc6838eacd8456d48603f4238954ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classSceneObject"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSceneObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSceneObject.html">SceneObject</a></td></tr>
<tr class="memitem:a0d3334cd8ccdb4f7370a17c736233b1d inherit pub_types_classSceneObject"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">Order</a> { <a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1daa9e6cd02b50c6727c75be1fcca8f2e86">LEFT</a>, 
<a class="el" href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1da0ae44da3aba1751789da10746e732db5">RIGHT</a>
 }</td></tr>
<tr class="memdesc:a0d3334cd8ccdb4f7370a17c736233b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum specifying matrix multiplication order  <a href="classSceneObject.html#a0d3334cd8ccdb4f7370a17c736233b1d">More...</a><br /></td></tr>
<tr class="separator:a0d3334cd8ccdb4f7370a17c736233b1d inherit pub_types_classSceneObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classGeometry.html" title="A Geometry is a SceneObject that holds Surfaces which contain mesh data and textures. ">Geometry</a> is a <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> that holds Surfaces which contain mesh data and textures. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa918fc922ada5e9fb838bd502602b475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat3 Geometry::getNormalMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a the transposed inverse of the modelMatrix. this should be used to transform normals into world space. the inverse is used since the normals of a scaled vector are inversely scaled, the transpose is used to revert the inversion of the rotational components while not affecting the scale factors which lie on the main diagonal. mat3 is used since the translational component is irrelevant for normals. </p>
<dl class="section return"><dt>Returns</dt><dd>the matrix to transform normals into world space. </dd></dl>

</div>
</div>
<a class="anchor" id="a642e705400989b354f1c001813bbf7b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classTexture.html">Texture</a> &gt; Geometry::loadMaterialTexture </td>
          <td>(</td>
          <td class="paramtype">aiMaterial *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">aiTextureType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load assimp aiMesh texture of given type. textures of same filePath are reused among the geometry object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>the assimp mesh material </td></tr>
    <tr><td class="paramname">type</td><td>the aiTextureType </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the texture </dd></dl>

</div>
</div>
<a class="anchor" id="aeed1fc7590be736468e6d2b0845e5c73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::loadSurfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load surfaces from file note: this loads only the first diffuse, specular and normal texture for each surface and stores them in this order in the surface </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>the path of the file to load surfaces from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac853ba774a9bcefbc24d6e5934ea6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::processMesh </td>
          <td>(</td>
          <td class="paramtype">aiMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>scene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load data from assimp aiMesh to new <a class="el" href="classSurface.html" title="A Surface holds mesh data (vertex data and indices) and textures. This communicates with Vertex Buffe...">Surface</a> object note: this loads only the first diffuse, specular and normal texture for each surface and stores them in this order in the surface </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the aiMesh to process </td></tr>
    <tr><td class="paramname">scene</td><td>the aiScene containing the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5a1ea6e3fb86cfef73973b64b86fd64e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::processNode </td>
          <td>(</td>
          <td class="paramtype">aiNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>scene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>process all meshes contained in given node and recursively process all child nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the current node to process </td></tr>
    <tr><td class="paramname">scene</td><td>the aiScene containing the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7146c1743d75b861a1d310aefe863068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeDelta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update the state of the <a class="el" href="classSceneObject.html" title="A SceneObject holds a transformation matrix and its inverse and provides functions to manipulate them...">SceneObject</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeDelta</td><td>the time passed since the last frame in seconds </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classPlayer.html#afdceffffd4625301ce378e08fa342721">Player</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>SEGANKU/<a class="el" href="geometry_8h_source.html">geometry.h</a></li>
<li>SEGANKU/geometry.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 22 2015 22:18:11 for Seganku by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
